 # AUTHENTICATION APP WITH RATE LIMITER
 ### Video Demo:  https://youtu.be/gy8zwpGeDAU
 ### Description:
 #### Abstract:
 This final project application written in Python reflects an authentication process in a simplified manner. It has been developed by Paul Münzner in the context of Harvard's course 'CS50’s Introduction to Programming with Python'. It offers the user to select two different options. One can either register with an email address and password or try to login by providing an email address and a password. The password for registration is validated with regex as it needs to meet a certain format. The email address is validated by using the pip installed validators library. The input for the login on the other hand is not validated to not provide any hints to malicious users. Once the registration is successful, the related data - email address and password in a hashed format - is saved to a CSV file as it is needed for following logins. In the case the user choose the login, the procedure is different. First of all, the program checks if there were not more than 3 failed login attempts with this email address during the last 10 minutes. In principle this is a rate limiter. If the rate limit threshold has been passed, the access is denied and the program stops. The login attempt failed. If the user did not reach the 3 failed login attempts within the last 10 minutes, the login process continues and checks if the password is correct. If the passwords doen't match, this failed attempt is saved in a second CSV file to provide the these information for the rate limiter. If a registration with the provided email address exists in registrations.csv and the provided password matches with the registered password, the user successfully passed all requirements of the login procedure.

 #### Flowchart for this application

![My Image](cs50-flowchart-paul-muenzner.png)

 #### Details:
 The following paragraphs provide more detail information for each function used in the app
 ##### Responses in string format:
 All applied responses in this program are centrally collected in a dictionary called `lib`, which is partially nested. The required string can be selected by its related keys attached to `lib` in square brackets and quotation marks, for example `lib["login"]["success"]`. This lib is positioned at the bottom of the project.py file.

 ##### Function def auth_selection(auth_type):
 The function auth_selection(auth_type) is one of the simplest functions in this program and represents the starting point. It allows the user with an if else condition to chose between the 'register' or 'login' process. The input is not case sensitive. The return value - 'register' or 'login' - is needed by the program to then select the correct functions needed for the login process or registration process. In case the user does not enter register or login, the program raises a ValueError and stops. This function only needs one argument (auth_type), which is the first input at the start of this application.

 ##### Function def input_request(auth_type, prop):
 The function input_request(auth_type, prop) is used to request the second part of the user input directly after auth_selection(auth_type). Function input_request(auth_type, prop) collects the email address and/or password and can be used for the registration but also for the login process. This reduces (duplicate) code as both email address and password are needed for login and registration. It allows to collect email address and password for two process option with only one function. The function needs two arguments - `auth_type` ('login' or 'register') and request parameter email address or password. The applied answers are selected depending if the user chose 'login' or 'register' and depending on if the email address or password needs to be collected. The selection can be implemented with if else expressions. However, it is implemented with ternary operators. Ternary operators also allow to test a condition but in a single line only. Ternary operators are especially suited if only two different conditions exist. If the `auth_type` is 'register', the program checks the required format of the email address with `validate_email_format(request)` or password with `validate_password_format(request)` with the help of a while loop until the correct format is provided - a valid email address or a password with minimum 10, maximum 16 characters consisting of numbers and/or letters (lowercase or upper case) and/or special characters `+=,\.@-_`.

 ##### Function def validate_email_format(email):
 The function validate_email_format(email) only takes an email as input to validate the format with the help of the package validators. The package validators was suggested in this CS50 course. It reduces the risk of wrong and complex email regex which, if done correctly and in-depth, can be several lines long. If the email address format is correct, def validate_email_format(email) returns `True`, if not it returns `False`.

 ##### Function def validate_password_format(password):
 The function validate_password_format(password) only takes a password as input to validate the format with the help of the re package and the regex `^[A-Za-z0-9+=,\.@-_]{10,16}$`. The re module with in-depth RegEx explanations is part of this CS50 course. This RegEx validation reduces the risk of too simple passwords which might be easy to guess. The password must have a minimum of 10 or maximum or 16 characters - defined with the RegEx part `{10,16}`. Allowed characters are numbers and/or letters (lowercase or upper case) and/or special characters `+=,\.@-_` - all defined with the RegEx part `[A-Za-z0-9+=,\.@-_]`. If the password format is correct, def validate_password_format(password) returns `True`, if not it returns `False`.

 ##### Function def process_registraion(password, email):
 The function process_registraion(password, email) handles the registration process and needs two arguments - the successfully validated password and email. In the very first step it reads the csv file called registrations.csv with the code line `list = read_csv("registrations")`. With a for loop, this function checks if the provided email has already been registered and added to the registrations.csv. If yes, the response 'You are registered. Feel free to sign in.' is printed. If this email is not written in the csv file and therefore has not been registered yet, 'registrations.csv' will be opened by using `with open("registrations.csv", "a") as file:` and the provided and validated email address and hashed password will be added in one line with `writer.writerow()` for the only two existing field names in this file. After that, the same response 'You are registered. Feel free to sign in.' is returned. Csv handling, writing and reading, has been teached in this CS50 course. Thanks for that!

 ##### Function def process_login(password, email):
 The function process_login(password, email) handles the login process and applies password and email address as argument. At the very beginning, this function reads the registrations.csv file with `read_csv("registrations")` to check line by line with the help of a for loop if there is an existing registration based on the provided email address. The loop stops if an existing user has been found. Three three needed variables `user_exist=True`, `user_password` and `user_email` are defined in this case. If no user is registered, user_exist is set to False and the application stops with an error response in the next step. If user_exist is set to True brute force attacks are defended in a simplified manner by using `rate_limit_check(email)`. As you can read later, `rate_limit_check(email)` only returns True or False. If True (to many failures), Python's SystemExit exception with a message is raised. If returned False the user with the provided email address did not reach the permitted maximum of more than three failed logins within the last 10 minutes; the process continues. In the next step, the hashed password `user_password` from regsitrations.csv will be checked against the provided password (argument of this function). The validation of the provided password for login means a comparison with the hashed password from the registration with password_match(password, hash). The `password_match(password, hash)` returns True if the password is correct and a False if the password does not match with the registration password. The function `password_match(password, hash)` will be explained later in this document. If the password does not match, the rate limit method comes into play again. However, in this case, the file logger.csv will be opened with the code line `with open("logger.csv", "a") as file:` in order to log one failed login attempt needed for later login attempts. One new line/entry in logger.csv consists of the email address used for the failed login attempt and a date stamp in order to check in later login attempts if the time window of ten minutes has been exceeded or not. For consistency, the date format UTC+1 (London) is used and provided with the function `time_now_london()`; explained soon. In this case, the program exits with Python's SystemExit exception with a non-informative message from the afore-mentioned string library 'lib' by calling `lib["login"]["wrong_credentials"]`. If the provided email address exists in registrations.csv and the password matches, the user is successfully signed in and receives the printed message 'Successfully signed in. Welcome to my app!' called with `lib["login"]["success"]`.

 ##### Function def time_now_london():
 The function time_now_london() needs no arguments. It uses the by pip installed datetime package documented here: https://docs.python.org/3/library/datetime.html .
 With `datetime.now()`, one receives the current date stamp in a very detailed format. It provides years, months, days, hours, minutes, seconds, and microseconds of the date/time now. It is also possible to get a particular time zone. Several modules can be used for that purpose. Here, `timezone` with `timedelta` from datetime package is applied to in the end format the time zone to the London time (UTC+1) with the help of line `time_zone_london = timezone(timedelta(hours=1))`. As per documentation, timedelta allows to express the difference between two dates, times, or datetimes. with the help of timezone(), the correct timezone format for the chosen timedelta of one hour `timedelta(hours=1)` can be provided, in this case the output is '1:00:00'. In this case for London, the format will be `UTC+01:00` (generated with `timezone(timedelta(hours=1))`). Based on the selected timezone `UTC+01:00`, datetime.now(time_zone_london) provides the detailed London time. This function is used in `rate_limit_check(email)` and `process_login(password, email)`.

 ##### Function def rate_limit_check(email):
 The function rate_limit_check(email) needs the email address as input. First of all, it opens the logger.csv which holds all failed login attempts with fields email and time (London time zone). The variable 'count' is used in the following for loop to count and hold all registered failed login attempts for the provided email address during the last 10 minutes. Variable `time_window_min` defines the time window in minutes where the failed login attempts occurred. Variable `max_allowed_failed_logins` is used to define the number of allowed failures for the login process during the last ten minutes defined with `time_window_min`. Variable time_now holds the current time in the moment it has been called and instantiated. This current time is needed to compare the time difference from now to each time stamp of the logged login failure that has been written to logger.csv including this time stamp and the related email. The comparison is taking place inside the for loop in function rate_limit_check(email) with `difference_minutes = time_now.timestamp()/60 - log_date.timestamp()/60` for each matched email. If difference_minutes is smaller than `time_window_min`, the count variable will be increased by 1. Variable log_date holds the time stamp of the logged time and generates the needed format (year-month-day hour-minutes-seconds.milliseconds) by applying strptime() with `datetime.strptime(log['date'], '%Y-%m-%d %H:%M:%S.%f%z')`. The format of both time or date values - `time_now` and `log_date` - will be converted to a float value representing passed seconds since 1 Jan 1970 by using `timestamp()`. The result will be divided by 60 in both cases to receive the passed minutes. This is one way to easily calculate the time difference with `time_now.timestamp()/60 - log_date.timestamp()/60`, compare both dates and check if the difference is larger than 10 minutes. As `time_now.timestamp()` and `log_date.timestamp()` are expressed in passed seconds since 1 Jan 1970, both values are divided by 60 to substract log_date from time_now and validate if the results in minutes is larger than `time_window_min` - in this app 10 minutes. This function rate_limit_check(email) only returns a boolean and is used in afore-mentioned function process_login(password, email) only.

 ##### Function def read_csv(type):
 The function read_csv(type) needs one argument as input. This can be the name of the file to read in the framework of this Python program. This name is type of string and able to be 'logger' or 'registrations'. The value is case-sensitive. Any other value will raise a ValueError with code line `raise ValueError(lib["wrong_file_type_read"])`. Depending on the provided type, the function will read registrations.csv or logger.csv. The content of this csv file will be provided as a Python dictionary with the help of `csv.DictReader(file)`. The input of the csv.DictReader() function is a file object. A DictReaderobject will be returned. It is then possible to loop through the rows of variable content and append each row content to variable fileList with `filelist.append(row)`. This allows to in the end return the content of the requested csv file as a Python dictionary for further processing. Very important at this point is the exception handler provided by Python and explained in this CS50 course during week 3. If the program is applied first time, the needed csv files do not exist if not provided. In this case they must be created. Otherwise, this Python application will not work as intended. If the exception is raised because the file does not exist (`except FileNotFoundError`), the not existing file will be created in the following lines of code. The file alone will be created with `with open(file_name, "w") as file`. Important is here the "w" to create and write this file. In the next line, starting with the variable `newheader`, the header will be defined with a ternary operator depending on the requested file type 'logger' or 'registrations'. The registrations file has the header fields 'email' and 'password'. The logger file has the header fields 'email' and 'date'. The following two lines of code `writer = csv.DictWriter(file, fieldnames= newheader)` and `writer.writeheader()` finally are used to add the header to the file. As the file did not exist before and has just been newly created, an empty dictionary [] will be returned.

 ##### Function def hash_password(password):
 The function hash_password(password) needs one argument as input, the validated password during the registration process. Hashing passwords is a method of protecting them by converting them into a series of random characters. This is not comparable to encryption. Encryption is used to conceal information. The encrypted information can be reversed again. However, reversing a hash is not possible. Password hashing is a one-way function. If the user repeats the password during the login process, the repeated password will be hashed with the same algorithm and 'salt' as the password during registration process. The password hash of the password during registration and the hash of the repeated password during login can be compared and will be identic if both passwords are identic. This enables to not store password in clear text in a database or here csv file. An attacker having access to this data cannot decrypt and use the hash to login. The package bcrypt is used to hash the password. Each provided password needs to be encoded with `password.encode('utf-8')` before hashing as bcrypt needs byte strings and not Unicode strings. Furthermore a salt is needed and provided with `bcrypt.gensalt()`. The salt will be a random string each time and makes the hash unpredictable during hashing the password.

 ##### Function def password_match(password, hash):
 The function password_match(password, hash) is used in the process_login(password, email) function to check if the provided password matches with the password provided during registration. Function password_match(password, hash) needs two arguments as input. The password provided by the user during the login process and the hashed password from the registrations.csv. Similar as in hash_password(password) function, both arguments - password and password hash - must be encoded to byte strings. Otherwise bcrypt will raise an error. In case the user enters the correct password during login process both passwords/hashes match and password_match(password, hash) returns True. Function password_match(password, hash) returns false if the user provides a wrong password different to the registration process.

 ##### Testing in test_project.py with pytest:
 In accordance to the requirements of CS50's Final Project description, at least three testing function have to be implemented. The following functions used in project.py are tested: `password_match()` (with test_validate_email()), `validate_password()` (with test_validate_password()), `validate_email()` (with test_validate_email()), and `auth_selection()` (with test_auth_selection()).

 ## Applied Python methods from CS50 course
 The following lists is an extract of applied methods in my final project application teached in CS50’s Introduction to Programming with Python
 - Of course, functions and variables in nearly each row - covered in CS50 week 0
 - Conditionals in eight functions, such as function process_login(password, email) of password_match(password, hash) - covered in CS50 week 1
 - While loops and for loops, such as in function input_request(auth_type, prop) - covered in CS50 week 2
 - Exception handling in function read_csv(type) - covered in CS50 week 3
 - Import and usage of libraries, such as bcrypt, datetime or validators - covered in CS50 week 4
 - Unit testing with pytest as required for the final project - covered in CS50 week 5
 - Writing and reading CSV files: registrations.csv and logger.csv - covered in CS50 week 6
 - Regular expressions wit re package to validate the password format. Email format is also validated with help of validators package - covered in CS50 week 7

 ## Applied methods not part of CS50 course (extract)
 - Ternary operators are used, especially in function `input_request(auth_type, prop)`. This is a shorthand alternative for writing short if-else conditions. They are documented in Python docs here: https://docs.python.org/3/reference/expressions.html#conditional-expressions or described here https://www.blog.pythonlibrary.org/2012/08/29/python-101-the-ternary-operator/
 - Hashing strings, here passwords, with the widely used package bcrypt. Also for comparing hashes. Information from https://pypi.org/project/bcrypt/ & https://github.com/pyca/bcrypt/
 - Collecting and handling strings for user responses in one place in a Python dictionary.
 - Creating files automatically by the program with `open(file_name, "w")`. The function `read_csv(type)` triggers the creation of the file it it does not exist. This commonly is the case when using the program the first time.
 - Creating date stamps for a specified time zone by using Python's # datetime from https://docs.python.org/3/library/datetime.html, timezone from https://docs.python.org/3/library/datetime.html#datetime.datetime.utcnow together with timedelta https://docs.python.org/3/library/datetime.html#timedelta-objects
 - Using timestamp() to convert datetime to seconds https://pynative.com/python-datetime-to-seconds/ and https://docs.python.org/3/library/datetime.html#datetime.datetime.timestamp

 ## Final Project requirements defined by CS50 course
 This project called 'Authentication App with Rate Limiter' meets the requirements of the Harvard course 'CS50’s Introduction to Programming with Python' as per description at https://cs50.harvard.edu/python/2022/project/
 - This project is implemented in Python. No other programming language is used.
 - This project has a main function and and more than the three additional required functions. In total and without the main function, this project uses 11 Python functions. Four of those are accompanied by tests that can be executed with pytest in test_project.py
 - The main function is in the file called project.py, which should is in the “root” of my 'Authentication App with Rate Limiter' project
 - The required custom functions other than main are also in project.py and defined at the same indentation level as main
 - All test functions are placed in `test_project.py`, which is also placed in the root folder of my project. All tested functions have test_ prepended to the name in the testing file: `password_match()` (with test_validate_email()), `validate_password()` (with test_validate_password()), `validate_email()` (with test_validate_email()), and `auth_selection()` (with test_auth_selection())
 - More than the minimum of 3 functions are implemented in this app as offered in the CS50 Final Project requirements
 - The time implementing this project required more time and effort than is required by each of the course’s problem sets
 - All pip-installed libraries are listed in requirements.txt